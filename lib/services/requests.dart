import 'dart:convert';
import 'dart:math';
import 'package:combined_playlist_maker/models/my_response.dart';
import 'package:combined_playlist_maker/models/playlist.dart';
import 'package:combined_playlist_maker/models/track.dart';
import 'package:combined_playlist_maker/models/user.dart';
import 'package:combined_playlist_maker/models/artist.dart';
import 'package:combined_playlist_maker/services/recommendator.dart';
import 'package:combined_playlist_maker/services/statistics.dart';
import 'package:crypto/crypto.dart';
import 'package:flutter/foundation.dart';
import 'package:hive_flutter/hive_flutter.dart';
import 'package:http/http.dart';
import 'package:url_launcher/url_launcher.dart';

const SCOPE =
    'user-read-private user-read-email user-top-read playlist-modify-public playlist-modify-private ugc-image-upload';
// Get the environment variables
String clientId = '26cd2b5bfc8a431eb6b343e28ced0b6f';
String redirectUri =
    'https://combined-playlist-maker.vercel.app'; //'http://localhost:5000/'

/// Generates a random string of the specified [length].
///
/// The generated string will consist of alphanumeric characters (uppercase and lowercase) and digits.
///
/// Example:
/// ```dart
/// String randomString = generateRandomString(10);
/// print(randomString); // Output: "aBcDeFgHiJ"
/// ```
String generateRandomString(int length) {
  final random = Random();
  const possible =
      'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  String text = '';

  for (int i = 0; i < length; i++) {
    text += possible[random.nextInt(possible.length)];
  }

  return text;
}

/// Generates a code challenge for OAuth 2.0 PKCE (Proof Key for Code Exchange) flow.
///
/// The code challenge is generated by calculating the SHA-256 hash of the provided [codeVerifier],
/// and then converting the hash into a Base64 URL-encoded string.
///
/// The resulting code challenge is suitable for use in OAuth 2.0 authorization requests.
///
/// Returns the generated code challenge as a string.
String generateCodeChallenge(String codeVerifier) {
  var data = ascii.encode(codeVerifier);
  var hash = sha256.convert(data);
  String base64UrlEncoded = base64Url
      .encode(hash.bytes)
      .replaceAll("=", "")
      .replaceAll("+", "-")
      .replaceAll("/", "_");
  return base64UrlEncoded;
}

/// Obtains the current URL code.
///
/// This function retrieves the code parameter from the current URL.
/// It is an asynchronous function that returns a dynamic value.
/// The code parameter is obtained from the query parameters of the current URL.
/// If the code parameter is not present, it returns an empty string.
///
/// Returns:
///   - The code parameter from the current URL, or an empty string if it is not present.
///
/// Example usage:
/// ```dart
/// dynamic code = await obtainCurrentURLCode();
/// print(code);
/// ```
dynamic obtainCurrentURLCode() async {
  String? code = '';
  Uri uri;

  uri = Uri.base;

  code = uri.queryParameters['code'];

  return code;
}

/// Requests authorization from the user to access their Spotify account.
/// Generates a random code verifier and saves it for the authentication process.
/// Generates a code challenge based on the code verifier.
/// Generates a random state value.
/// Constructs the authorization URL with the necessary parameters.
/// Launches the authorization URL in a web browser.
/// Throws an exception if the authorization URL cannot be launched.
Future<void> requestAuthorization() async {
  var codeVerifier = generateRandomString(128);

  // guardamos el codeVerifier para el proceso de autenticación
  // después lo guardaré con el usuario
  var cvBox = Hive.box('codeVerifiers');
  var n = cvBox.length;
  await cvBox.put('cv$n', codeVerifier);

  String codeChallenge = generateCodeChallenge(codeVerifier);

  String state = generateRandomString(16);

  final args = {
    'response_type': 'code',
    'client_id': clientId,
    'scope': SCOPE,
    'redirect_uri': redirectUri,
    'state': state,
    'code_challenge_method': 'S256',
    'code_challenge': codeChallenge,
  };

  final authorizationUrl =
      Uri.https('accounts.spotify.com', '/authorize', args);

  if (await canLaunchUrl(authorizationUrl)) {
    await launchUrl(authorizationUrl, webOnlyWindowName: '_self');
  } else {
    throw 'Could not launch $authorizationUrl';
  }
}

bool isAuthenticated() {
  //auth es una caja de Hive que simplemente guarda un booleano
  var auth = Hive.box('auth').toMap();
  var users = Hive.box<User>('users').toMap();
  if (auth.isEmpty && users.isEmpty) {
    return false;
  } else {
    return true;
  }
}

/// Retrieves the access token from Spotify API using the authorization code.
/// Returns a [MyResponse] object containing the response status code and content.
/// If successful, the access token is stored in the [content] field of the [MyResponse] object.
/// If an error occurs, an empty [content] field is returned.
Future<MyResponse> getAccessToken() async {
  String? code;

  MyResponse ret = MyResponse();

  //obtengo el codigo de la url y lo guardo
  code = await obtainCurrentURLCode();

  var cvBox = Hive.box('codeVerifiers');
  var codeVerifier = await cvBox.get('cv${cvBox.length - 1}');
  cvBox.clear();
  if (codeVerifier == null) {
    // no hay un codeVerifier, asi que va a dar error, cortamos ejecución
    ret.content = {};
    return ret;
  }
  final body = {
    'grant_type': 'authorization_code',
    'code': code,
    'redirect_uri': redirectUri,
    'client_id': clientId,
    'code_verifier': codeVerifier,
  };

  try {
    final response = await post(
      Uri.parse('https://accounts.spotify.com/api/token'),
      headers: {'Content-Type': 'application/x-www-form-urlencoded'},
      body: body,
    );

    ret.statusCode = response.statusCode;
    if (response.statusCode == 200) {
      final data = json.decode(response.body);
      ret.content = data;
      return ret;
    } else {
      ret.content = {};
      throw Exception('HTTP status ${response.statusCode} in getAccessToken');
    }
  } catch (error) {
    if (kDebugMode) {
      print('Error $error');
    }
    return ret;
  }
}

/// Retrieves the Spotify profile information for the authenticated user.
/// Returns a [MyResponse] object containing the status code and content.
/// If the access token is not obtained correctly, the status code will be set accordingly
/// and the content will be a [User] object indicating that the user is not valid.
/// If the request is successful, the status code will be 200 and the content will be
/// a [User] object representing the retrieved user information.
/// Throws an exception if the HTTP status code is not 200.
/// Returns the [MyResponse] object.
Future<MyResponse> retrieveSpotifyProfileInfo() async {
  MyResponse ret = MyResponse();
  MyResponse tokenResponse = await getAccessToken();
  if (tokenResponse.statusCode != 200) {
    //no se ha llegado a hacer la petición porque el token
    //no se ha obtenido correctamente
    ret.statusCode = tokenResponse.statusCode;
    ret.content = User.notValid();
    return ret;
  }

  final Uri uri = Uri.parse('https://api.spotify.com/v1/me');
  User newUser;

  try {
    final response = await get(
      uri,
      headers: {
        'Authorization': 'Bearer ${tokenResponse.content['access_token']}'
      },
    );
    ret.statusCode = response.statusCode;
    if (response.statusCode == 200) {
      final data = json.decode(response.body);
      newUser = User.fromJson(data, tokenResponse.content['access_token'],
          tokenResponse.content['refresh_token']);
      var usersBox = Hive.box<User>('users');
      await usersBox.put(newUser.id, newUser);
      ret.content = newUser;
      return ret;
    } else {
      if (kDebugMode) {
        print(json.decode(response.body));
      }
      ret.content = User.notValid();
      throw Exception(
          'HTTP status ${response.statusCode} en retrieveSpotifyProfileInfo');
    }
  } catch (error) {
    print('Error: $error');
    return ret;
  }
}

/// Retrieves the top items of a user from the Spotify API.
///
/// The [userId] parameter specifies the ID of the user.
/// The [type] parameter specifies the type of top items to retrieve (e.g., 'tracks', 'artists').
/// The [timeRange] parameter specifies the time range for the top items (e.g., 'short_term', 'medium_term', 'long_term').
/// The [limit] parameter specifies the maximum number of items to retrieve.
///
/// Returns a [Future] that resolves to a [MyResponse] object containing the response data.
/// If successful, the [MyResponse.content] field will contain a list of parsed top items.
/// If an error occurs, the [MyResponse.statusCode] field will be set accordingly and the [MyResponse.content] field will be an empty list.
/// If an exception is thrown, the [MyResponse.statusCode] field will be unset and the [MyResponse.content] field will be an empty list.
Future<MyResponse> getUsersTopItems(
    String userId, String type, String timeRange, double limit) async {
  var usersBox = Hive.box<User>('Users');
  User? user = usersBox.get(userId);
  var accessToken = user!.accessToken;

  MyResponse ret = MyResponse();

  final args = {
    'time_range': timeRange,
    'limit': limit.round().toString(),
  };

  final Uri uri = Uri.https('api.spotify.com', '/v1/me/top/$type', args);
  try {
    final response = await get(
      uri,
      headers: {'Authorization': 'Bearer $accessToken'},
    );
    ret.statusCode = response.statusCode;
    if (response.statusCode == 200) {
      final data = json.decode(response.body);
      ret.content = parseItemData(data, type);
      return ret;
    } else {
      ret.content = [];
      throw Exception('HTTP status ${response.statusCode} en getUsersTopItems');
    }
  } catch (error) {
    print(ret);
    print('Error: $error');
    return ret;
  }
}

/// Parses the item data based on the given type.
///
/// The function takes in the `data` and `type` parameters and returns a list of parsed items.
/// If the `type` is 'artists', it parses the data as a list of artists and returns a list of Artist objects.
/// If the `type` is not 'artists', it parses the data as a list of tracks and returns a list of Track objects.
///
/// Example usage:
/// ```dart
/// List parsedItems = parseItemData(data, 'artists');
/// ```
List parseItemData(data, type) {
  List topItems = [];
  if (type == 'artists') {
    for (var item in data['items']) {
      Artist a = Artist.fromJson(item);
      topItems.add(a);
    }
  } else {
    for (var item in data['items']) {
      Track a = Track.fromJson(item);
      topItems.add(a);
    }
  }
  return topItems;
}

/// Retrieves recommendations from the Spotify API based on the provided parameters.
///
/// The [userId] parameter is the ID of the user making the request.
/// The [genreSeeds] parameter is a list of genre seeds to use for the recommendations.
/// The [artistSeeds] parameter is a list of artist seeds to use for the recommendations.
/// The [trackSeeds] parameter is a list of track seeds to use for the recommendations.
/// The [limit] parameter is the maximum number of recommendations to retrieve.
///
/// Returns a [Future] that resolves to a [MyResponse] object containing the recommendations.
/// If an error occurs during the request, an empty [MyResponse] object is returned.
Future<MyResponse> getRecommendations(String userId, List? genreSeeds,
    List? artistSeeds, List? trackSeeds, double limit) async {
  var usersBox = Hive.box<User>('Users');
  User? user = usersBox.get(userId);
  var accessToken = user!.accessToken;

  MyResponse ret = MyResponse();
  List recommendations = [];

  final args = {
    'market': 'ES',
    'limit': limit.round().toString(),
    'seed_artists': artistSeeds,
    'seed_genres': genreSeeds,
    'seed_tracks': trackSeeds,
  };

  final Uri uri = Uri.https('api.spotify.com', '/v1/recommendations', args);
  try {
    final response = await get(
      uri,
      headers: {'Authorization': 'Bearer $accessToken'},
    );

    ret.statusCode = response.statusCode;
    if (response.statusCode == 200) {
      final data = json.decode(response.body);
      for (var item in data['tracks']) {
        Track t = Track.fromJson(item);
        recommendations.add(t);
      }
      ret.content = recommendations;
      return ret;
    } else {
      ret.content = response.body;
      throw Exception(
          'HTTP status ${response.statusCode} in getRecommendations');
    }
  } catch (error) {
    print('Error: $error');
    return ret;
  }
}

Future<MyResponse> getGenreSeeds(String userId) async {
  var usersBox = Hive.box<User>('Users');
  User? user = usersBox.get(userId);
  var accessToken = user!.accessToken;

  MyResponse ret = MyResponse();

  final Uri uri =
      Uri.https('api.spotify.com', '/v1/recommendations/available-genre-seeds');

  try {
    final response = await get(
      uri,
      headers: {'Authorization': 'Bearer $accessToken'},
    );

    ret.statusCode = response.statusCode;
    if (response.statusCode == 200) {
      final data = json.decode(response.body);
      ret.content = data['genres'];
      return ret;
    } else {
      print(json.decode(response.body));
      throw Exception('HTTP status ${response.statusCode} in getGenreSeeds');
    }
  } catch (error) {
    ret.content = [];
    print('Error: $error');
  }
  return ret;
}

/// Refreshes the access token for the specified user.
///
/// This method sends a request to the Spotify API to refresh the access token
/// using the provided refresh token. The refreshed access token is then stored
/// in the [User] object associated with the specified [userId].
///
/// Returns a [MyResponse] object containing the response from the API.
/// If the request is successful, the response will contain the refreshed access token.
/// If the request fails, an exception is thrown.
///
/// Throws an exception if there is an error during the request.
Future<MyResponse> refreshToken(userId) async {
  MyResponse ret = MyResponse();

  //obtengo el codigo de la url y lo guardo
  var usersBox = Hive.box<User>('users');
  User? u = usersBox.get(userId);

  final body = {
    'grant_type': 'refresh_token',
    'refresh_token': u!.refreshToken,
    'client_id': clientId,
  };

  try {
    final response = await post(
      Uri.parse('https://accounts.spotify.com/api/token'),
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: body,
    );

    ret.statusCode = response.statusCode;
    if (response.statusCode == 200) {
      final data = json.decode(response.body);
      ret.content = data;
      return ret;
    } else {
      print(json.decode(response.body));
      ret.content = {};
      throw Exception('HTTP status ${response.statusCode} in refreshToken');
    }
  } catch (error) {
    print('Error $error');
    print(ret);
    return ret;
  }
}

/// Obtains recommendations for all users based on their top tracks and artists.
///
/// The [numTracks] parameter specifies the number of top tracks to consider for each user. The default value is 3.
/// The [numArtists] parameter specifies the number of top artists to consider for each user. The default value is 2.
/// The [tracksTerm] parameter specifies the time range for the top tracks. The default value is 'short_term'.
/// The [artistsTerm] parameter specifies the time range for the top artists. The default value is 'long_term'.
///
/// Returns a [Future] that resolves to a [MyResponse] object containing the recommendations for all users.
/// The recommendations are stored in the [content] property of the [MyResponse] object.
/// If an error occurs during the process, the [content] property will contain an error message.
/// The [statusCode] property of the [MyResponse] object indicates the status of the operation.
Future<MyResponse> obtainAllUsersRecommendations(
    {double numTracks = 3,
    double numArtists = 2,
    String tracksTerm = 'short_term',
    String artistsTerm = 'long_term'}) async {
  MyResponse ret = MyResponse();

  var usersBox = Hive.box<User>('users').toMap();

  // * Auxiliary data for statistics and debugging
  Map<String, List> usersArtistSeeds = {};
  Map<String, List> usersTrackSeeds = {};
  // * End of auxiliary data

  Map<String, List> recommendations = {};

  for (var user in usersBox.values) {
    user.updateToken(); // actualizo el token del usuario
    var userId = user.id;

    // obtengo los items top del usuario
    MyResponse topTracks =
        await getUsersTopItems(userId, 'tracks', tracksTerm, numTracks);
    if (topTracks.statusCode != 200) {
      ret.content = {'error': 'error retrieving top tracks'};
      ret.statusCode = topTracks.statusCode;
      return ret;
    }
    List? trackSeeds = topTracks.content.map((track) => track.id).toList();

    MyResponse topArtists =
        await getUsersTopItems(userId, 'artists', artistsTerm, numArtists);
    if (topArtists.statusCode != 200) {
      ret.content = {'error': 'error retrieving top artists'};
      ret.statusCode = topArtists.statusCode;
      return ret;
    }
    List? artistSeeds = topArtists.content.map((artist) => artist.id).toList();

    MyResponse userRecommendations =
        await getRecommendations(userId, [], artistSeeds, trackSeeds, 100);
    if (userRecommendations.statusCode != 200) {
      ret.content = {'error': userRecommendations.content};
      ret.statusCode = userRecommendations.statusCode;
      return ret;
    }
    ret.statusCode = userRecommendations.statusCode;

    // * Auxiliary data for statistics and debugging
    usersArtistSeeds[userId] = artistSeeds!;
    usersTrackSeeds[userId] = trackSeeds!;
    // * End of auxiliary data

    recommendations[userId] = userRecommendations.content;
  }

  // * Auxiliary data for statistics and debugging
  Map seedOverlapping = obtainSeedsOverlapping(
      usersArtistSeeds, usersTrackSeeds, numArtists as int, numTracks as int);
  // * End of auxiliary data

  ret.content = recommendations;
  // * Auxiliary data for statistics and debugging
  ret.auxContent = seedOverlapping;
  // * End of auxiliary data

  return ret;
}

/// Generates a combined playlist based on user recommendations.
///
/// The [duration] parameter specifies the desired duration of the playlist.
/// The [type] parameter specifies the type of seed to use for playlist generation.
/// If [type] is null, a default seed type will be used.
///
/// Returns a [Future] that resolves to a [MyResponse] object containing the generated playlist.
/// The [MyResponse] object has a [statusCode] indicating the status of the request,
/// and a [content] field containing the generated playlists.
Future<MyResponse> generateCombinedPlaylist(
    Duration duration, String? type) async {
  MyResponse ret = MyResponse();
  MyResponse recommendations = await obtainAllUsersRecommendations();
  if (recommendations.statusCode != 200) {
    ret.statusCode = recommendations.statusCode;
    ret.content = recommendations.content;
    return ret;
  }
  // indicates the number of seeds for each type of seed
  // [0] = artists, [1] = tracks, [2] = genres
  // the sum of the values must be 5
  List<int> seedProp = [2, 0, 3];
  Map<String, List> playlists = generateRecommendedPlaylist(
      recommendations.content, duration, seedProp, type);

  // ! Taking into account that there will be two strategies to compare for users
  // ! tests, we will eliminate one of the playlists if it totally overlaps with the other one
  // ! This is done to avoid having two playlists that are exactly the same
  if (playlists.length == 2) {
    // lo hacemos para las pruebas de usuarios donde se comparan 2 estrategias
    playlists = removeIfOverlaps(playlists);
    ret.auxContent = {'msg': 'Playlist removed due to total overlap'};
  }

  ret.statusCode = recommendations.statusCode;
  ret.content = playlists;

  return ret;
}

/// Saves a playlist to Spotify.
///
/// [items] - The list of items to add to the playlist.
/// [userId] - The ID of the user creating the playlist.
/// [name] - The name of the playlist.
/// [description] - The description of the playlist.
/// [isPublic] - Whether the playlist should be public or not.
/// [isCollaborative] - Whether the playlist should be collaborative or not.
/// [coverImage] - The path to the cover image of the playlist.
///
/// Returns a [MyResponse] object with the status code and content.
Future<MyResponse> savePlaylistToSpotify(
    List items,
    String userId,
    String name,
    String description,
    bool isPublic,
    bool isCollaborative,
    String coverImage) async {
  MyResponse ret = MyResponse();

  String playlistId = '';

  MyResponse creationResponse = await createPlaylistOnSpotify(
      userId, name, description, isPublic, isCollaborative);
  if (creationResponse.statusCode == 201) {
    if (kDebugMode) {
      print('Playlist created successfully');
    }
    playlistId = creationResponse.content['id'];
    if (coverImage != '') {
      await uploadCoverImage(userId, playlistId, coverImage);
    }
    MyResponse addTracksResponse = await addTracksToPlaylist(
        userId, creationResponse.content['id'], items);
    if (addTracksResponse.statusCode == 201) {
      if (kDebugMode) {
        print('Tracks added to playlist successfully');
      }
      ret.statusCode = 201;
      ret.content = creationResponse.content;
      // ! Debugging
      if (kDebugMode) {
        print(ret.content);
      }
    } else {
      // error adding tracks
      ret.statusCode = addTracksResponse.statusCode;
      ret.content = addTracksResponse.content;
    }
  } else {
    // error creating playlist
    ret.statusCode = creationResponse.statusCode;
    ret.content = creationResponse.content;
  }

  return ret;
}

/// Uploads the cover image for a playlist.
///
/// This method takes the [userId], [playlistId], and [coverImage] as parameters and uploads the cover image to the specified playlist on Spotify.
/// It retrieves the user's access token from the Hive box and includes it in the request headers for authorization.
/// The [coverImage] parameter should be a JPEG image.
///
/// Returns a [MyResponse] object with the status code and content of the response.
/// If the cover image is uploaded successfully, the status code will be 202 and the content will be 'Cover Uploaded Successfully'.
/// If an error occurs during the upload process, an exception will be thrown.
Future<MyResponse> uploadCoverImage(
    String userId, String playlistId, String coverImage) async {
  var usersBox = Hive.box<User>('Users');
  User? user = usersBox.get(userId);
  var accessToken = user!.accessToken;

  MyResponse ret = MyResponse();

  try {
    final response = await put(
      Uri.parse('https://api.spotify.com/v1/playlists/$playlistId/images'),
      headers: {
        'Authorization': 'Bearer $accessToken',
        'Content-Type': 'image/jpeg',
      },
      body: coverImage,
    );
    ret.statusCode = response.statusCode;
    if (response.statusCode == 202) {
      ret.content = {'msg': 'Cover Uploaded Successfully'}; // * No content
      // ! Debugging
      if (kDebugMode) {
        print(ret);
      }
      return ret;
    } else {
      ret.content = {'error': '${json.decode(response.body)}'};
      throw Exception('HTTP status ${response.statusCode} in uploadCoverImage');
    }
  } catch (error) {
    if (kDebugMode) {
      print('Error $error');
      print(ret);
    }
    return ret;
  }
}

/// Creates a playlist on Spotify for the specified user.
///
/// The [userId] parameter is the ID of the user for whom the playlist is being created.
/// The [name] parameter is the name of the playlist.
/// The [description] parameter is the description of the playlist.
/// The [isPublic] parameter indicates whether the playlist should be public.
/// The [isCollaborative] parameter indicates whether the playlist should be collaborative.
///
/// Returns a [MyResponse] object containing the response from the Spotify API.
/// If the playlist is created successfully, the [MyResponse.content] field will contain the playlist data.
/// If an error occurs, the [MyResponse.statusCode] field will be set to the HTTP status code and an exception will be thrown.
Future<MyResponse> createPlaylistOnSpotify(String userId, String name,
    String description, bool isPublic, bool isCollaborative) async {
  MyResponse ret = MyResponse();
  var usersBox = Hive.box<User>('Users');
  User? user = usersBox.get(userId);
  var accessToken = user!.accessToken;

  // * Important to do json.encode for the body to be a String
  final body = json.encode({
    "name": name,
    "description": description,
    "public": isCollaborative ? false : isPublic,
    "collaborative": isCollaborative,
  });

  try {
    final response = await post(
      Uri.parse('https://api.spotify.com/v1/users/$userId/playlists'),
      headers: {
        'Authorization': 'Bearer $accessToken',
        'Content-Type': 'application/json',
      },
      body: body,
    );
    ret.statusCode = response.statusCode;
    if (response.statusCode == 201) {
      final data = json.decode(response.body);
      ret.content = data;
      return ret;
    } else {
      ret.content = {'error': '${json.decode(response.body)}'};
      throw Exception(
          'HTTP status ${response.statusCode} in createPlaylistOnSpotify');
    }
  } catch (error) {
    if (kDebugMode) {
      print('Error $error');
      print(ret);
    }

    return ret;
  }
}

/// Adds tracks to a playlist.
///
/// This method takes a [userId], [playlistId], and a list of [tracks] to be added to the playlist.
/// It returns a [MyResponse] object containing the status code and content of the response.
/// The [userId] is used to retrieve the user's access token from the Hive database.
/// The [playlistId] is the ID of the playlist where the tracks will be added.
/// The [tracks] list contains the tracks to be added, represented by their IDs.
/// The method sends a POST request to the Spotify API to add the tracks to the playlist.
/// It sets the appropriate headers and body of the request, including the access token and track URIs.
/// If the request is successful (status code 201), it returns the response content.
/// Otherwise, it throws an exception with the corresponding HTTP status code.
/// If an error occurs during the request, it returns an empty [MyResponse] object.
Future<MyResponse> addTracksToPlaylist(
    String userId, String playlistId, List tracks) async {
  MyResponse ret = MyResponse();
  var usersBox = Hive.box<User>('Users');
  User? user = usersBox.get(userId);
  var accessToken = user!.accessToken;

  // * Important to do json.encode for the body to be a String
  final body = json.encode({
    "uris": tracks.map((e) => 'spotify:track:${e.id}').toList(),
  });

  try {
    final response = await post(
      Uri.parse('https://api.spotify.com/v1/playlists/$playlistId/tracks'),
      headers: {
        'Authorization': 'Bearer $accessToken',
        'Content-Type': 'application/json',
      },
      body: body,
    );

    ret.statusCode = response.statusCode;
    if (response.statusCode == 201) {
      final data = json.decode(response.body);
      ret.content = data;
      return ret;
    } else {
      ret.content = {'error': '${json.decode(response.body)}'};
      throw Exception(
          'HTTP status ${response.statusCode} in addTracksToPlaylist');
    }
  } catch (error) {
    if (kDebugMode) {
      print('Error $error');
      print(ret);
    }
    return ret;
  }
}

/// Retrieves a playlist from the Spotify API.
///
/// The [playlistId] parameter specifies the ID of the playlist to retrieve.
/// The [userId] parameter specifies the ID of the user who owns the playlist.
///
/// Returns a [MyResponse] object containing the response from the API.
/// If the request is successful, the [MyResponse.content] property will contain
/// a [Playlist] object representing the retrieved playlist.
/// If the request fails, an exception will be thrown.
Future<MyResponse> getPlaylist(String playlistId, String userId) async {
  MyResponse ret = MyResponse();
  var usersBox = Hive.box<User>('Users');
  User? user = usersBox.get(userId);
  var accessToken = user!.accessToken;

  try {
    final response = await get(
      Uri.parse('https://api.spotify.com/v1/playlists/$playlistId'),
      headers: {
        'Authorization': 'Bearer $accessToken',
      },
    );

    ret.statusCode = response.statusCode;
    if (response.statusCode == 200) {
      final data = json.decode(response.body);
      ret.content = Playlist.fromJson(data);
      return ret;
    } else {
      ret.content = {'error': '${json.decode(response.body)}'};
      throw Exception('HTTP status ${response.statusCode} in getPlaylist');
    }
  } catch (error) {
    if (kDebugMode) {
      print('Error $error');
      print(ret);
    }
    return ret;
  }
}
